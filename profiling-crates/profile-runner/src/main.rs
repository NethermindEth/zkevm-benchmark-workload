//! # Profile Runner
//! 
//! A benchmarking tool for executing and profiling EVM test cases using RISC0 ZKVM.
//! This crate processes JSON test files containing EVM execution scenarios and
//! generates execution proofs with performance metrics.

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    PROFILE_ELF, PROFILE_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Serialize, Deserialize};
use revm::context::TxEnv;
use revm::primitives::{U256, Address, Bytes, TxKind};
use std::collections::HashMap;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};


#[derive(Serialize, Deserialize)]
struct ExecutionOutput {
    success: bool,
    gas_used: u64,
    output: Option<Vec<u8>>,
    error: Option<String>,
    cycles_used: Option<u64>,
}

// Structs matching the guest code
#[derive(Debug, Serialize, Deserialize)]
struct TestCase {
    env: Environment,
    pre: HashMap<String, Account>,
    transaction: Transaction,
    post: HashMap<String, Vec<PostState>>,
    config: Config,
}

#[derive(Debug, Serialize, Deserialize)]
struct Environment {
    #[serde(rename = "currentCoinbase")]
    current_coinbase: String,
    #[serde(rename = "currentGasLimit")]
    current_gas_limit: String,
    #[serde(rename = "currentNumber")]
    current_number: String,
    #[serde(rename = "currentTimestamp")]
    current_timestamp: String,
    #[serde(rename = "currentDifficulty")]
    current_difficulty: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct Account {
    nonce: String,
    balance: String,
    code: String,
    storage: HashMap<String, String>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Transaction {
    nonce: String,
    #[serde(rename = "gasPrice")]
    gas_price: String,
    #[serde(rename = "gasLimit")]
    gas_limit: Vec<String>,
    to: String,
    value: Vec<String>,
    data: Vec<String>,
    sender: String,
    #[serde(rename = "secretKey")]
    secret_key: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct PostState {
    hash: String,
    logs: String,
    txbytes: String,
    indexes: HashMap<String, u64>,
    state: HashMap<String, Account>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Config {
    chainid: String,
}

// Helper function to parse hex string to U256
fn parse_hex_to_u256(hex_str: &str) -> U256 {
    let clean_hex = if hex_str.starts_with("0x") {
        &hex_str[2..]
    } else {
        hex_str
    };
    U256::from_str_radix(clean_hex, 16).expect("Invalid hex string")
}

// Helper function to parse hex string to u64
fn parse_hex_to_u64(hex_str: &str) -> u64 {
    let clean_hex = if hex_str.starts_with("0x") {
        &hex_str[2..]
    } else {
        hex_str
    };
    u64::from_str_radix(clean_hex, 16).expect("Invalid hex string")
}

// Helper function to parse hex string to u128
fn parse_hex_to_u128(hex_str: &str) -> u128 {
    let clean_hex = if hex_str.starts_with("0x") {
        &hex_str[2..]
    } else {
        hex_str
    };
    u128::from_str_radix(clean_hex, 16).expect("Invalid hex string")
}

// Helper function to parse hex string to Address
fn parse_hex_to_address(hex_str: &str) -> Address {
    let clean_hex = if hex_str.starts_with("0x") {
        &hex_str[2..]
    } else {
        hex_str
    };
    
    let bytes = hex::decode(clean_hex).expect("Invalid hex string");
    let mut addr_bytes = [0u8; 20];
    if bytes.len() <= 20 {
        addr_bytes[20 - bytes.len()..].copy_from_slice(&bytes);
    } else {
        addr_bytes.copy_from_slice(&bytes[bytes.len() - 20..]);
    }
    
    Address::from(addr_bytes)
}

// Helper function to parse hex string to bytes
fn parse_hex_to_bytes(hex_str: &str) -> Vec<u8> {
    let clean_hex = if hex_str.starts_with("0x") {
        &hex_str[2..]
    } else {
        hex_str
    };
    hex::decode(clean_hex).expect("Invalid hex string")
}



fn create_tx_env(test_case: &TestCase) -> TxEnv {
    // Create transaction environment from test case
    let to = if test_case.transaction.to == "" {
        None
    } else {
        Some(parse_hex_to_address(&test_case.transaction.to))
    };

    let data = if test_case.transaction.data.is_empty() {
        Bytes::new()
    } else {
        Bytes::from(parse_hex_to_bytes(&test_case.transaction.data[0]))
    };

    let value = if test_case.transaction.value.is_empty() {
        U256::ZERO
    } else {
        parse_hex_to_u256(&test_case.transaction.value[0])
    };

    let gas_limit = if test_case.transaction.gas_limit.is_empty() {
        0
    } else {
        parse_hex_to_u64(&test_case.transaction.gas_limit[0])
    };

    let gas_price = parse_hex_to_u128(&test_case.transaction.gas_price);

    // Use default TxEnv and modify only the fields we need
    let mut tx_env = TxEnv::default();
    tx_env.caller = parse_hex_to_address(&test_case.transaction.sender);
    tx_env.gas_limit = gas_limit;
    tx_env.gas_price = gas_price;
    tx_env.kind = TxKind::Call(to.unwrap_or(parse_hex_to_address(&test_case.transaction.sender)));
    tx_env.value = value;
    tx_env.data = data;
    tx_env.chain_id = Some(parse_hex_to_u64(&test_case.config.chainid));
    tx_env.nonce = parse_hex_to_u64(&test_case.transaction.nonce);
    tx_env
}

// Function to scan directory for JSON files and execute all test cases
fn scan_and_execute_tests(directory_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let dir_path = Path::new(directory_path);
    
    if !dir_path.exists() {
        return Err(format!("Directory {} does not exist", directory_path).into());
    }
    
    if !dir_path.is_dir() {
        return Err(format!("{} is not a directory", directory_path).into());
    }
    
    println!("Scanning directory: {}", directory_path);
    
    // Collect all JSON files recursively
    let json_files = find_json_files(dir_path)?;
    
    if json_files.is_empty() {
        println!("No JSON files found in directory: {}", directory_path);
        return Ok(());
    }
    
    println!("Found {} JSON files to process", json_files.len());
    
    // Initialize the prover once
    let prover = default_prover();
    
    // Process each JSON file
    for json_file in json_files {
        println!("\n=== Processing file: {} ===", json_file.display());
        
        match process_json_file(&json_file, &prover) {
            Ok(_) => println!("Successfully processed {}", json_file.display()),
            Err(e) => eprintln!("Error processing {}: {}", json_file.display(), e),
        }
    }
    
    Ok(())
}

// Function to recursively find all JSON files in a directory
fn find_json_files(dir: &Path) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>> {
    let mut json_files = Vec::new();
    
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_dir() {
            // Recursively search subdirectories
            let sub_files = find_json_files(&path)?;
            json_files.extend(sub_files);
        } else if path.is_file() {
            // Check if it's a JSON file
            if let Some(extension) = path.extension() {
                if extension == "json" {
                    json_files.push(path);
                }
            }
        }
    }
    
    Ok(json_files)
}

// Function to process a single JSON file
fn process_json_file(json_file: &Path, prover: &std::rc::Rc<dyn risc0_zkvm::Prover>) -> Result<(), Box<dyn std::error::Error>> {
    // Read the JSON file
    let json_content = fs::read_to_string(json_file)
        .map_err(|e| format!("Failed to read file {}: {}", json_file.display(), e))?;
    
    // Parse the JSON file
    let test_cases: HashMap<String, TestCase> = serde_json::from_str(&json_content)
        .map_err(|e| format!("Failed to parse JSON in {}: {}", json_file.display(), e))?;
    
    println!("Found {} test cases in {}", test_cases.len(), json_file.display());
    
    // Create results file for this JSON file
    let results_filename = format!("results/execution_results_{}.txt", 
        json_file.file_stem().unwrap().to_string_lossy());
    let mut results_file = File::create(&results_filename)
        .map_err(|e| format!("Failed to create results file {}: {}", results_filename, e))?;
    
    writeln!(results_file, "=== Execution Results for {} ===", json_file.display())?;
    writeln!(results_file, "Total test cases: {}", test_cases.len())?;
    writeln!(results_file, "")?;
    
    let mut successful_tests = 0;
    let mut failed_tests = 0;
    
    let total_tests = test_cases.len();
    
    // Process each test case
    for (test_name, test_case) in test_cases {
        println!("  Processing test case: {}", test_name);
        
        match execute_single_test(&test_name, &test_case, prover) {
            Ok(output) => {
                successful_tests += 1;
                
                // Write results to file
                writeln!(results_file, "Test: {}", test_name)?;
                writeln!(results_file, "  Success: {}", output.success)?;
                writeln!(results_file, "  Gas used: {}", output.gas_used)?;
                if let Some(cycles) = output.cycles_used {
                    writeln!(results_file, "  Cycles used: {}", cycles)?;
                }
                if let Some(ref output_data) = output.output {
                    writeln!(results_file, "  Output: {:?}", output_data)?;
                }
                if let Some(ref error) = output.error {
                    writeln!(results_file, "  Error: {}", error)?;
                }
                writeln!(results_file, "")?;
            }
            Err(e) => {
                failed_tests += 1;
                eprintln!("    Error executing test {}: {}", test_name, e);
                
                // Write error to file
                writeln!(results_file, "Test: {}", test_name)?;
                writeln!(results_file, "  Error: {}", e)?;
                writeln!(results_file, "")?;
            }
        }
    }
    
    // Write summary
    writeln!(results_file, "=== Summary ===")?;
    writeln!(results_file, "Successful tests: {}", successful_tests)?;
    writeln!(results_file, "Failed tests: {}", failed_tests)?;
    writeln!(results_file, "Total tests: {}", total_tests)?;
    
    println!("  Completed: {} successful, {} failed", successful_tests, failed_tests);
    println!("  Results written to: {}", results_filename);
    
    Ok(())
}

// Function to execute a single test case
fn execute_single_test(test_name: &str, test_case: &TestCase, prover: &std::rc::Rc<dyn risc0_zkvm::Prover>) -> Result<ExecutionOutput, Box<dyn std::error::Error>> {
    // Create transaction environment from the test case
    let tx_env = create_tx_env(test_case);
    
    // Create the executor environment with both tx_env and test_case
    let env = ExecutorEnv::builder()
        .write(&tx_env)
        .map_err(|e| format!("Failed to write tx_env: {}", e))?
        .write(&test_case)
        .map_err(|e| format!("Failed to write test_case: {}", e))?
        .build()
        .map_err(|e| format!("Failed to build executor environment: {}", e))?;
    
    // Prove the execution
    let prove_info = prover
        .prove(env, PROFILE_ELF)
        .map_err(|e| format!("Failed to prove execution: {}", e))?;
    
    // Extract the receipt
    let receipt = prove_info.receipt;
    
    // Verify the proof
    receipt
        .verify(PROFILE_ID)
        .map_err(|e| format!("Failed to verify proof: {}", e))?;
    
    // Decode the execution output from the receipt journal
    let output: ExecutionOutput = receipt.journal.decode()
        .map_err(|e| format!("Failed to decode journal: {}", e))?;
    
    Ok(output)
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Check if a directory path is provided as command line argument
    let args: Vec<String> = std::env::args().collect();
    let directory_path = if args.len() > 1 {
        &args[1]
    } else {
        "tests" // Default to tests directory
    };

    println!("Starting test execution for directory: {}", directory_path);

    // Scan and execute all tests in the directory
    match scan_and_execute_tests(directory_path) {
        Ok(_) => println!("\nAll test execution completed successfully!"),
        Err(e) => {
            eprintln!("Error during test execution: {}", e);
            std::process::exit(1);
        }
    }
}
